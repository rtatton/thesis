\chapter{Data Structures}

\newcommand{\vDynamicSet}{\vSet{S}}
\newcommand{\vKey}{k}
\newcommand{\vElement}{x}
\newcommand{\aElementKey}{\aKey{\vElement}}

Let a \define{dynamic set} $\vDynamicSet$ be a mutable collection of distinct elements. Let $\vElement$ be a pointer to an element in $\vDynamicSet$ such that $\aElementKey$ uniquely identifies the element in $\vDynamicSet$ \cite{Cormen2022}. Let a \define{dictionary} be a dynamic set that supports insertion, deletion, and membership querying \cite{Cormen2022}:

\begin{itemize}
    \item $\cSearch[\vDynamicSet, \vKey]$ returns a pointer $\vElement$ to an element in the set $\vDynamicSet$ such that $\aElementKey \equals \vKey$; or $\nil$, if no such element exists in $\vDynamicSet$.
    \item $\cInsert[\vDynamicSet, \vElement]$ adds the element pointed to by $\vElement$ to $\vDynamicSet$.
    \item $\cDelete[\vDynamicSet, \vElement]$ removes the element pointed to by $\vElement$ from $\vDynamicSet$.
    \item $\cMinimum[\vDynamicSet]$ and $\cMaximum[\vDynamicSet]$ return a pointer $\vElement$ to the minimum and maximum element, respectively, of the totally ordered set $\vDynamicSet$; or $\nil$, if $\vDynamicSet$ is empty. Unlike \cite{Cormen2022}, this work permits attributes other than $\aElementKey$ to be used in the element ordering of $\vDynamicSet$.
\end{itemize}