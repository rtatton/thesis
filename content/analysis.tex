\chapter{Evaluation}

\section{Reference Implementation}

A reference implementation of \cref{sec:asynchronous} is available on GitHub\footnote{\url{https://github.com/cwru-xlab/sharetrace-akka}}. Actors are implemented using the Akka toolkit\footnote{\url{https://doc.akka.io/docs/akka/2.8.5/typed/index.html}}, which offers high-performance and large-scale actor systems. Experimental results indicate that the reference implementation can reliably handle contact networks with 1 million individuals and 10 million contacts, which makes it ideal for small-scale experiments. In addition to using the Akka toolkit, several other optimizations are implemented:
\begin{itemize}
  \item To reduce the size of event logs and result files, individual actor identifiers follow zero-based numbering and event records are serialized using the Ion format\footnote{\url{https://amazon-ion.github.io/ion-docs}} with shortened field names.
  \item To reduce memory usage, FastUtil\footnote{\url{https://fastutil.di.unimi.it}} data structures are used, including a specialized integer-based JGraphT\footnote{\url{https://jgrapht.org}} graph implementation \citep{Michail2020}. Also, singletons \citep{Gamma1995}, primitive data types, and reference equality are preferred where feasible and do not impact readability.
  \item To reduce runtime and increase throughput, logging is performed asynchronously with Logback\footnote{\url{https://logback.qos.ch/index.html}} and the LMAX Disruptor\footnote{\url{https://lmax-exchange.github.io/disruptor}}.
\end{itemize}

\Cref{fig:arrow-diagram} shows the dependencies among the application components. Contextualizing this implementation with prior implementations of the driver-monitor-worker (DMW) framework (see \cref{sec:dmw-framework}), \class{RiskPropagation} is the driver, \class{Monitor} is the monitor, and \class{User} is the worker. The key difference between this implementation and previous implementations of the DMW framework is that the workers are stateful, which is necessary for decentralization.
\begin{figure}[htbp]
\begin{equation*}
  \class{Main} \rightarrow \class{Runner} \rightarrow \class{RiskPropagation} \rightarrow \class{Monitor} \rightarrow \class{User} \rightarrow \class{Contact}
\end{equation*}
\caption[Arrow diagram of the reference implementation]{Arrow diagram of the reference implementation.}
\label{fig:arrow-diagram}
\end{figure}

\Cref{sec:asynchronous} describes the behavior of \class{User} and \class{Contact}. In order to evaluate \class{RiskPropagation}, a \class{User} also logs the following types of \class{UserEvent}:
\begin{itemize}
  \item \class{ContactEvent}: logged when the \class{User} receives an unexpired \class{ContactMessage}; contains the \class{User} identifier, the \class{Contact} identifier, and the contact time.
  \item \class{ReceiveEvent}: logged when the \class{User} receives an unexpired \class{RiskScoreMessage}; contains the \class{User} identifier, the \class{Contact} identifier, and the \class{RiskScoreMessage}.
  \item \class{UpdateEvent}: logged when the \class{User} updates its exposure score; contains the \class{User} identifier, the previous \class{RiskScoreMessage}, and the current \class{RiskScoreMessage}.
  \item \class{LastEvent}: logged when the \class{User} receives a \class{PostStop} Akka signal\footnote{\url{https://doc.akka.io/docs/akka/current/typed/actor-lifecycle.html\#stopping-actors}} after the \class{Monitor} has stopped; contains the \class{User} identifier and the time of logging the last event, besides \class{LastEvent}; used to detect the end time of message passing.
\end{itemize}

The \class{Monitor} is an actor that is responsible for transforming the \class{ContactNetwork} into a collection of \class{User} actors and terminating when no \class{UpdateEvent}s have occurred for a period of time. Similar to \class{User}s, the \class{Monitor} logs several types of \class{LifecycleEvent}, the meanings of which should be self-explanatory:
\begin{multicols}{2}
\begin{itemize}
  \item \class{CreateUsersStart}
  \item \class{CreateUsersEnd}
  \item \class{SendRiskScoresStart}
  \item \class{SendRiskScoresEnd}
  \item \class{SendContactsStart}
  \item \class{SendContactsEnd}
  \item \class{RiskPropagationStart}
  \item \class{RiskPropagationEnd}
\end{itemize}  
\end{multicols}

\class{RiskPropagation} logs execution properties, creates an Akka \class{ActorSystem} that creates a \class{Monitor} actor and sends it a \class{RunMessage}, and then waits until the \class{ActorSystem} terminates.

The \class{Runner} specifies how \class{RiskPropagation} is created and invoked, usually through some combination of statically defined behavior and runtime configuration.

Finally, \class{Main} is the entry point into the application. It is responsible for parsing \class{Context}, \class{Parameters}, and \class{Runner} from configuration and invoking \class{Runner} with \class{Context} and \class{Parameters} inputs. \class{Context} makes  application-wide information accessible, such as the system time and user time\footnote{System time is always the current time and is included in each logged event record. User time is configurable to either be the current time or fixed at the reference time. The latter is useful for avoiding the expiration of \class{RiskScoreMessage}s and \class{ContactMessage}s across executions of \class{RiskPropagation}.}, a pseudorandom number generator, \class{Runner} configuration, and loggers. \class{Parameters}, as the name suggests, is a collection of parameters that modify the behavior of the \class{Monitor}, \class{User}s, and \class{Contact}s.

An experiment typically composed of multiple configuration files in order to vary an aspect of the 

An execution is defined by one or more invocations of risk propagation that are associated with the same configuration file. 

Multiple invocations may be needed to compute statistics when the data generation process is stochastic.

An execution may involve multiple invocations of risk propagation in order to collect multiple results from the same configuration. This is particularly relevant when the data generation process involves 

Analysis sequence:

\begin{enumerate}
  \item Load execution properties.
  \item Stream the event log and process each record by one or more \class{EventHandler}s.
  \item Put the results from each \class{EventHandler} in a \class{Results} object.
  \item Transform the \class{Results} instance it into a tabular dataset.
  \item Analyze the dataset.
\end{enumerate}

\subsection{Experimental Design}

The following research questions were the focus of evaluation:

\begin{enumerate}
  \item How do the send coefficient and tolerance affect the accuracy and efficiency of risk propagation?
  \item What is the runtime performance of risk propagation?
\end{enumerate}

Barabasi--Albert graphs \citep{Barabasi1999} are parametrized by the order $n$, the initial order $n_0$, and the size increase $m_0$ upon each incremental increase to the order. The latter two parameters are determined by solving \cref{eq:barabasi-albert-optimization}, where $\fracpart(x)$ is the fractional part of a real number $x$.
\begin{argmini}{n_0, m_0}{\fracpart(m_0)}{\protect\label{eq:barabasi-albert-optimization}}{}
  \addConstraint{n_0}{\in \intInterval{1}{n - 1}}
  \addConstraint{m_0}{\in \intInterval{1}{n_0}}
  \addConstraint{m_0}{= \frac{2m - n_0 (n_0 - 1)}{2(n - n_0)}}
\end{argmini}
Erd\"{o}s--R\'{e}nyi $G_{n,m}$ random graphs \citep{Erdos1959} are parametrized by the order $n$ and the size $m$. Random regular graphs \citep{Kim2003} are parametrized by the order $n$ and, using the degree sum formula, the degree $d = \lfloor \frac{2m}{n} \rfloor$. Lastly, Watts--Strogatz graphs \citep{Watts1998} are parametrized by the order $n$, the rewiring probability $p$ and the number of nearest neighbors $k = d + (d \bmod 2)$, which must be even.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    Parameter & Default value \\
    \midrule
    Seed & \num{12345} \\
    Transmission rate & \num{0.8} \\
    Send coefficient & \num{1} \\
    Tolerance & \num{0} \\
    Time buffer & \qty{2}{days} \\
    Risk score expiry & \qty{14}{days} \\
    Contact expiry & \qty{14}{days} \\
    Flush timeout & \qty{3}{seconds} \\
    Idle timeout & \qty{1}{minute} \\
    \bottomrule
  \end{tabular}
  \caption[Default parameter values for evaluation]{Default parameter values for evaluation.}
  \label{tab:default-parameters}
\end{table}

The default Akka configuration\footnote{\url{https://doc.akka.io/docs/akka/current/general/configuration-reference.html}}.

\begin{itemize}
  \item Fixed clock time
  \item Monitor actor:
    \begin{itemize}
      \item PinnedDispatcher
      \item Thread pool executor 
      \item No core timeout
    \end{itemize}
  \item User actors:
    \begin{itemize}
      \item Dispatcher
      \item Thread pool executor
      \item \num{100} throughput
      \item Max pool size: \num{2147483647} (max Java integer value)
    \end{itemize}
  \item 5 contact networks with distinct risk scores and contact times
  \item Sampling procedure to generate dataset values: Given a probability density function $f_X$ and cumulative distribution function $F_X$ of a random variable $X$, sample a value $x \sim f_X$ and evaluate $F_X(x)$.
\end{itemize}

Parmeter experiments:

\begin{itemize}
  \item $n = 10^4$, $m = 5 \cdot 10^4$
  \item Distributions: uniform, standard normal
  \item Send coefficients: 0.8–2.0, in increments of 0.1
  \item Tolerance: 0.001–0.01, in increments of 0.001
  \item All 9 distribution combinations: uniform, standard normal
  \item 5 contact networks with distinct risk scores and contact times
\end{itemize}

Runtime baseline experiment:

\begin{itemize}
  \item $n = 10^4$, $m = 10^5$
  \item All 9 distribution combinations: uniform, standard normal
  \item 1 burn-in + 5 contact networks with distinct risk scores and contact times
  \item Log lifecycle events and last event for message-passing runtime
\end{itemize}

Runtime experiment:

\begin{itemize}
  \item Cross product of $n \in \setBuilder{10^5x}{x \in [1, 10]}$ and $m \in \setBuilder{10^6x}{x \in [1, 10]}$
  \item Uniform distribution for all 3 data types
  \item 1 burn-in + 5 contact networks with distinct risk scores and contact times
  \item Log lifecycle events and last event for message-passing runtime
\end{itemize}

%The value of \Cref{eq:reach} can be found by associating with each symptom score a unique identifier. If each actor maintains a log of the risk scores it receives, then the set of actors that receive the symptom score or a propagated risk score thereof can be identified. This set of actors defines the induced subgraph on which to compute \Cref{eq:reach} using a shortest-path algorithm \citep{Johnson1977}.

\subsection{Results}